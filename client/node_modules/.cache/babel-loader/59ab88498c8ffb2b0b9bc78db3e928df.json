{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null; // This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\n\nvar MISSING_VALUE = {};\nvar idCounter = 1; // Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\n\nvar makeSlotClass = function () {\n  return (\n    /** @class */\n    function () {\n      function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\"slot\", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(\":\");\n      }\n\n      Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n          // We use the Slot object iself as a key to its value, which means the\n          // value cannot be obtained without a reference to the Slot object.\n          if (this.id in context_1.slots) {\n            var value = context_1.slots[this.id];\n            if (value === MISSING_VALUE) break;\n\n            if (context_1 !== currentContext) {\n              // Cache the value in currentContext.slots so the next lookup will\n              // be faster. This caching is safe because the tree of contexts and\n              // the values of the slots are logically immutable.\n              currentContext.slots[this.id] = value;\n            }\n\n            return true;\n          }\n        }\n\n        if (currentContext) {\n          // If a value was not found for this Slot, it's never going to be found\n          // no matter how many times we look it up, so we might as well cache\n          // the absence of the value, too.\n          currentContext.slots[this.id] = MISSING_VALUE;\n        }\n\n        return false;\n      };\n\n      Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n          return currentContext.slots[this.id];\n        }\n      };\n\n      Slot.prototype.withValue = function (value, callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        var _a;\n\n        var slots = (_a = {\n          __proto__: null\n        }, _a[this.id] = value, _a);\n        var parent = currentContext;\n        currentContext = {\n          parent: parent,\n          slots: slots\n        };\n\n        try {\n          // Function.prototype.apply allows the arguments array argument to be\n          // omitted or undefined, so args! is fine here.\n          return callback.apply(thisArg, args);\n        } finally {\n          currentContext = parent;\n        }\n      }; // Capture the current context and wrap a callback function so that it\n      // reestablishes the captured context when called.\n\n\n      Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n          var saved = currentContext;\n\n          try {\n            currentContext = context;\n            return callback.apply(this, arguments);\n          } finally {\n            currentContext = saved;\n          }\n        };\n      }; // Immediately run a callback function without any captured context.\n\n\n      Slot.noContext = function (callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        if (currentContext) {\n          var saved = currentContext;\n\n          try {\n            currentContext = null; // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n\n            return callback.apply(thisArg, args);\n          } finally {\n            currentContext = saved;\n          }\n        } else {\n          return callback.apply(thisArg, args);\n        }\n      };\n\n      return Slot;\n    }()\n  );\n}; // We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\n\n\nvar globalKey = \"@wry/context:Slot\";\nvar host = Array;\n\nvar Slot = host[globalKey] || function () {\n  var Slot = makeSlotClass();\n\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false\n    });\n  } finally {\n    return Slot;\n  }\n}();\n\nvar bind = Slot.bind,\n    noContext = Slot.noContext;\n\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n} // Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\n\n\nfunction asyncFromGen(genFn) {\n  return function () {\n    var gen = genFn.apply(this, arguments);\n    var boundNext = bind(gen.next);\n    var boundThrow = bind(gen.throw);\n    return new Promise(function (resolve, reject) {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n\n        var next = result.done ? resolve : invokeNext;\n\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n\n      var invokeNext = function (value) {\n        return invoke(boundNext, value);\n      };\n\n      var invokeThrow = function (error) {\n        return invoke(boundThrow, error);\n      };\n\n      invokeNext();\n    });\n  };\n}\n\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n} // If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\n\n\nvar wrappedFibers = [];\n\nfunction wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    var wrap = function (obj, method) {\n      var fn = obj[method];\n\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    }; // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n\n\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n\n  return Fiber;\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };","map":{"version":3,"mappings":"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","names":["currentContext","MISSING_VALUE","idCounter","makeSlotClass","Date","now","Math","random","toString","slice","join","Slot","context_1","parent","id","slots","value","hasValue","callback","args","thisArg","__proto__","_a","apply","context","saved","arguments","globalKey","host","Array","Object","defineProperty","enumerable","writable","configurable","bind","noContext","setTimeoutWithContext","delay","setTimeout","asyncFromGen","genFn","gen","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","fn","prototype","push"],"sources":["C:\\Users\\poohb\\Desktop\\group-project-3\\client\\node_modules\\@wry\\context\\src\\slot.ts","C:\\Users\\poohb\\Desktop\\group-project-3\\client\\node_modules\\@wry\\context\\src\\context.ts"],"sourcesContent":["type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult, TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: TThis) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n","import { Slot } from \"./slot\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n"]},"metadata":{},"sourceType":"module"}