{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit } from 'graphql';\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { filterInPlace } from \"../common/filterInPlace.js\";\nimport { isField, isInlineFragment } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nvar TYPENAME_FIELD = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename'\n  }\n};\n\nfunction isEmpty(op, fragments) {\n  return op.selectionSet.selections.every(function (selection) {\n    return selection.kind === 'FragmentSpread' && isEmpty(fragments[selection.name.value], fragments);\n  });\n}\n\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\n\nfunction getDirectiveMatcher(directives) {\n  return function directiveMatcher(directive) {\n    return directives.some(function (dir) {\n      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);\n    });\n  };\n}\n\nexport function removeDirectivesFromDocument(directives, doc) {\n  var variablesInUse = Object.create(null);\n  var variablesToRemove = [];\n  var fragmentSpreadsInUse = Object.create(null);\n  var fragmentSpreadsToRemove = [];\n  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {\n    Variable: {\n      enter: function (node, _key, parent) {\n        if (parent.kind !== 'VariableDefinition') {\n          variablesInUse[node.name.value] = true;\n        }\n      }\n    },\n    Field: {\n      enter: function (node) {\n        if (directives && node.directives) {\n          var shouldRemoveField = directives.some(function (directive) {\n            return directive.remove;\n          });\n\n          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {\n            if (node.arguments) {\n              node.arguments.forEach(function (arg) {\n                if (arg.value.kind === 'Variable') {\n                  variablesToRemove.push({\n                    name: arg.value.name.value\n                  });\n                }\n              });\n            }\n\n            if (node.selectionSet) {\n              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                fragmentSpreadsToRemove.push({\n                  name: frag.name.value\n                });\n              });\n            }\n\n            return null;\n          }\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node) {\n        fragmentSpreadsInUse[node.name.value] = true;\n      }\n    },\n    Directive: {\n      enter: function (node) {\n        if (getDirectiveMatcher(directives)(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n\n  if (modifiedDoc && filterInPlace(variablesToRemove, function (v) {\n    return !!v.name && !variablesInUse[v.name];\n  }).length) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function (fs) {\n    return !!fs.name && !fragmentSpreadsInUse[fs.name];\n  }).length) {\n    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n  }\n\n  return modifiedDoc;\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        if (parent && parent.kind === 'OperationDefinition') {\n          return;\n        }\n\n        var selections = node.selections;\n\n        if (!selections) {\n          return;\n        }\n\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);\n        });\n\n        if (skip) {\n          return;\n        }\n\n        var field = parent;\n\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === 'export';\n        })) {\n          return;\n        }\n\n        return __assign(__assign({}, node), {\n          selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false)\n        });\n      }\n    }\n  });\n}, {\n  added: function (field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === 'connection';\n\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === 'key';\n      })) {\n        __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');\n      }\n    }\n\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\n\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\n\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\n\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === 'Variable' && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\n\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n\n          if (node.arguments) {\n            node.arguments.forEach(function (arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n  var allFragments = [];\n  selectionSet.selections.forEach(function (selection) {\n    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) {\n        return allFragments.push(frag);\n      });\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n  return allFragments;\n}\n\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n\n  if (definitionOperation === 'query') {\n    return document;\n  }\n\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: 'query'\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === 'client';\n    },\n    remove: true\n  }], document);\n\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter: function (node) {\n          if (node.selectionSet) {\n            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {\n              return isField(selection) && selection.name.value === '__typename';\n            });\n\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        }\n      }\n    });\n  }\n\n  return modifiedDoc;\n}","map":{"version":3,"mappings":"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","names":["invariant","visit","checkDocument","getOperationDefinition","getFragmentDefinition","getFragmentDefinitions","getMainDefinition","filterInPlace","isField","isInlineFragment","createFragmentMap","TYPENAME_FIELD","kind","name","value","isEmpty","op","fragments","selectionSet","selections","every","selection","nullIfDocIsEmpty","doc","getDirectiveMatcher","directives","directiveMatcher","directive","some","dir","test","removeDirectivesFromDocument","variablesInUse","Object","create","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","Variable","enter","node","_key","parent","Field","shouldRemoveField","remove","arguments","forEach","arg","push","getAllFragmentSpreadsFromSelectionSet","frag","FragmentSpread","Directive","v","length","removeArgumentsFromDocument","fs","removeFragmentSpreadFromDocument","addTypenameToDocument","assign","SelectionSet","skip","lastIndexOf","field","added","connectionRemoveConfig","willRemove","__DEV__","removeConnectionDirectiveFromDocument","hasDirectivesInSelectionSet","nestedCheck","hasDirectivesInSelection","getArgumentMatcher","config","argumentMatcher","argument","aConfig","argMatcher","OperationDefinition","variableDefinitions","filter","varDef","variable","argMatchCount_1","Argument","FragmentDefinition","allFragments","buildQueryFromSelectionSet","document","definition","definitionOperation","operation","removeClientSetsFromDocument","isTypenameOnly"],"sources":["C:\\Users\\poohb\\Desktop\\group-project-3\\client\\node_modules\\@apollo\\src\\utilities\\graphql\\transform.ts"],"sourcesContent":["import { invariant } from '../globals';\n\nimport {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from '../common/filterInPlace';\nimport { isField, isInlineFragment } from './storeUtils';\nimport {\n  createFragmentMap,\n  FragmentMap,\n} from './fragments';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field' as Kind,\n  name: {\n    kind: 'Name' as Kind,\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll first check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // document.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !!v.name && !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !!fs.name && !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport const addTypenameToDocument = Object.assign(function (\n  doc: DocumentNode\n): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}, {\n  added(field: FieldNode): boolean {\n    return field === TYPENAME_FIELD;\n  },\n});\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true,\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ) : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach(arg => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n"]},"metadata":{},"sourceType":"module"}